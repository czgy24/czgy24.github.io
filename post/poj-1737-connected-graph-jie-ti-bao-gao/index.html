<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>POJ-1737 Connected Graph解题报告 | Gridea</title>
<link rel="shortcut icon" href="https://czgy24.github.io/favicon.ico?v=1620563622290">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://czgy24.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="POJ-1737 Connected Graph解题报告 | Gridea - Atom Feed" href="https://czgy24.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="大致题意:
求n个带标号的点组成的连通图的数目。

对于这种题，我们首先想到设计状态。设fif_ifi​代表i个带标号点组成的联通图的数目。发现直接来做不行，考虑分成两部分：所有方案和不可行方案
对于所有的方案，非常简单，显然所有的方案一共..." />
    <meta name="keywords" content="" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://czgy24.github.io">
  <img class="avatar" src="https://czgy24.github.io/images/avatar.png?v=1620563622290" alt="">
  </a>
  <h1 class="site-title">
    Gridea
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              POJ-1737 Connected Graph解题报告
            </h2>
            <div class="post-info">
              <span>
                2021-05-09
              </span>
              <span>
                7 min read
              </span>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h4 id="大致题意">大致题意:</h4>
<pre><code>求n个带标号的点组成的连通图的数目。
</code></pre>
<p>对于这种题，我们首先想到设计状态。设<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>f</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">f_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>代表i个带标号点组成的联通图的数目。发现直接来做不行，考虑分成两部分：<strong>所有方案和不可行方案</strong><br>
对于所有的方案，非常简单，显然所有的方案一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mi>i</mi><mo>∗</mo><mo>(</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{i*(i-1)/2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>种<br>
不可行方案的求法：枚举一个j表示1号点中包含的节点数目，也就是说，对于余下的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个点，选出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">j-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>个点来构成无向联通图。显而易见，选法一共有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mrow><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>)</mo><mo>∗</mo><mo>(</mo><mi>i</mi><mo>−</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>)</mo><mi mathvariant="normal">/</mi><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{(i-j)*(i-j-1)/2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8879999999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8879999999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mclose mtight">)</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mord mtight">/</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span>种，而j个点的联通图数量又有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>f</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">f[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>个，所以最终要减去$\sum_{j=1}<sup>{i-1}f[j]*C_{i-1}</sup>{j-1}<em>2^{(i-j)</em>(i-j-1)/2} $。</p>
<p>最终得出， $f[i]=2<sup>{i*(i-1)/2}-\sum_{j=1}</sup>{i-1}f[j]<em>C_{i-1}<sup>{j-1}*2</sup>{(i-j)</em>(i-j-1)/2} $<br>
需要注意的是，这道恶心的题目需要用高精，在本篇Blog最下方分享一个<strong>zyf</strong>大佬的高精模板。</p>
<pre><code class="language-cpp">//正解代码
#include&lt;bits/stdc++.h&gt;
using namespace std;
bign f[52];
bign power[1226];
bign C[51][51];
signed main() {
	power[0]=1;
	for(int i=1; i&lt;1226; i++) {
		power[i]=power[i-1]*2;
	}
	for(int i=0; i&lt;=50; ++i) {
		C[i][0]=1;
		for(int j=1; j&lt;=i; ++j)
			C[i][j]=(C[i-1][j-1]+C[i-1][j]);
	}
	f[1]=1;
	for(int i=2; i&lt;=50; i+=1) {
		f[i]=power[i*(i-1)/2];
		for(int j=1; j&lt;i; j++)
			f[i]-=f[j]*C[i-1][j-1]*power[(i-j)*(i-j-1)/2];
	}
	while(1) {
		int n;
		cin&gt;&gt;n;
		if(n==0)break;
		cout&lt;&lt;f[n]&lt;&lt;endl;
	}
	return 0;
}
</code></pre>
<pre><code class="language-cpp">namespace zyf {
	struct bign {
		static const int maxlen=2000,width=8;
		static const long long limit=100000000LL;
		long long len,bit[maxlen];
		long long&amp; operator[](int p) {
			return bit[p];
		}
		void ClearBit() {
			memset(bit,0,sizeof(bit));
		}
		void Delete0() {
			for(; !bit[len-1] &amp;&amp; len&gt;1; --len);
		}

		bign(int p=0) {
			*this=p;
		}
		bign&amp; operator=(int p) {
			ClearBit();
			len=p?0:1;
			for(; p; p/=limit) bit[len++]=p%limit;
			return *this;
		}
		bign(const char *p) {
			*this=p;
		}
		bign&amp; operator=(const char *p) {
			ClearBit();
			len=0;
			for(int i=strlen(p)-1; i&gt;=0; i-=width) {
				int now=0;
				for(int j=max(0,i-width+1); j&lt;=i; ++j) now=now*10+(p[j]-'0');
				bit[len++]=now;
			}
			return *this;
		}

		bign&amp; operator+=(bign b) {
			len=max(len,b.len)+1;
			for(int i=0; i&lt;len; ++i) bit[i]+=b[i],bit[i+1]+=bit[i]/limit,bit[i]%=limit;
			Delete0();
			return *this;
		}
		bign&amp; operator-=(bign b) {
			for(int i=0; i&lt;len; ++i) {
				bit[i]-=b[i];
				if(bit[i]&lt;0) bit[i]+=limit,--bit[i+1];
			}
			Delete0();
			return *this;
		}
		bign&amp; operator*=(bign b) {
			bign a=*this;
			ClearBit();
			len=a.len+b.len;
			for(int i=0; i&lt;a.len; ++i)
				for(int j=0; j&lt;b.len; ++j)
					bit[i+j]+=a[i]*b[j],bit[i+j+1]+=bit[i+j]/limit,bit[i+j]%=limit;
			Delete0();
			return *this;
		}
		bign&amp; operator*=(int b) {
			++len;
			long long t=0;
			for (int i=0; i&lt;len; ++i)
				bit[i]=t+bit[i]*b,t=bit[i]/limit,bit[i]%=limit;
			Delete0();
			return *this;
		}

		bign&amp; operator/=(int b) {
			for(int i=len-1; i&gt;0; --i) bit[i-1]+=limit*(bit[i]%b),bit[i]/=b;
			bit[0]/=b;
			Delete0();
			return *this;
		}

		bool operator&lt;(bign b) const {
			if(len&gt;b.len) return false;
			if(len&lt;b.len) return true;
			for(int i=len-1; i&gt;=0; --i)
				if(bit[i]!=b[i]) return bit[i]&lt;b[i];
			return bit[0]&lt;b[0];
		}
		bool operator==(bign b) const {
			return !(*this&lt;b) &amp;&amp; !(b&lt;*this);
		}
		bool operator!=(bign b) const {
			return !(*this==b);
		}
		bool operator&gt;(bign b) const {
			return !(*this&lt;b) &amp;&amp; !(*this==b);
		}
		bool operator&lt;=(bign b) const {
			return *this&lt;b || *this==b;
		}
		bool operator&gt;=(bign b) const {
			return *this&gt;b || *this==b;
		}

		bool odd() {
			return bit[0]%2==1;
		}
		bool even() {
			return bit[0]%2==0;
		}
	};
	bign operator+(bign a,bign b) {
		return a+=b;
	}
	bign operator-(bign a,bign b) {
		return a-=b;
	}
	bign operator*(bign a,bign b) {
		return a*=b;
	}
	bign operator*(bign a,int b) {
		return a*=b;
	}
	bign operator/(bign a,int b) {
		return a/=b;
	}
	istream&amp; operator&gt;&gt;(istream &amp;is,bign &amp;p) {
		string s;
		is&gt;&gt;s;
		p=s.c_str();
		return is;
	}
	ostream&amp; operator&lt;&lt;(ostream &amp;os,bign p) {
		os.fill('0');
		os&lt;&lt;p.bit[p.len-1];
		for(int i=p.len-2; i&gt;=0; --i) {
			os.width(bign::width);
			os&lt;&lt;p.bit[i];
		}
		return os;
	}
	bign sqrt(bign x) {
		bign head=1,tail=x;
		while(head&lt;=tail) {
			bign mid=(head+tail)/2;
			if(x&lt;mid*mid) tail=mid-1;
			else head=mid+1;
		}
		return tail;
	}
	bign gcd(bign a,bign b) {
		bign gcd=1;
		while(a!=b) {
			if(a&lt;b) swap(a,b);
			if(a.even() &amp;&amp; b.even()) gcd*=2,a/=2,b/=2;
			else if(a.even() &amp;&amp; b.odd()) a/=2;
			else if(a.odd() &amp;&amp; b.even()) b/=2;
			else a=a-b;
		}
		return gcd*=a;
	}
}
using zyf::bign;
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#%E5%A4%A7%E8%87%B4%E9%A2%98%E6%84%8F">大致题意:</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://czgy24.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
